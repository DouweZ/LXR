___modulation stuff___
There are 3 types of modulation

Velocity__
params: PAR_VEL_DEST_1-6
data type: DTYPE_TARGET_SELECTION_VELO 
You can modulate a parameter based on the velocity value on each step for a voice. You select one parameter to modulate.
The parameter is one of the parameters on the SAME voice. The left 5 bits of the param value select the page
within the voice and the right 3 bits select one of the 8 params on that page. This resolves ultimately to a parameter
which is applicable to that voice. It can be empty though because some menu items are empty. The data that gets sent to
the back is a parameter number and the voice number.

Strategy for fix: the param value will change to represent a value in modTargets rather than an encoded reference into
to menu pages. (search **VELO in the code). This means the value range will not be 0..n but rather n..m where n is the
start for that voice and m is the end.

LFO__
params: PAR_TARGET_LFO*, PAR_VOICE_LFO*
data type: DTYPE_TARGET_SELECTION_LFO
LFO's can target a parameter to modulate. A separate parameter controls which voice the parameter is on. So therefore
the param value represents a parameter on that voice. Left 5 bits of the param value select the page, and right 3 bits
selects one of the 8 params on that page. works similar to velocity above. 
We are in effect storing duplicate info here. The voice number is purely for ui whereas the target effectively stores both
the voice and the param on that voice since it's just an offset into modTargets which includes parameters on all voices.
the voice number is 1 based.

Strategy: same as velocity search **LFO

Automation__
params: PAR_P1_DEST, PAR_P2_DEST
data type: DTYPE_AUTOM_TARGET
sequencer modulation - per sequencer step, you can modulate two parameters. The value here represents a parameter number,
so you can select any of the voice parameter values (effectively letting you modulate a param on any voice).
menu_cc2name is used here to lookup descriptive name for a parameter. This is different from lfo and velocity in that the value
represents a parameter directly
Problem: some of the values are invalid mod targets.
menu_cc2name is just a way to get a name index and a voice number given a parameter number. This name index is into valueNames array
which itself is a reference to long names, short names and category names for everything. menu_cc2name is only used by automation target.
frontParser_stepData is a struct in front that stores among other things, these two values. It seems that it's only used to 
store values it requests from cortex so that it can save these to sd card and vice versa.

Strategy for automation target fix: (search for **AUTOM in the code)
- Do not modify the cortex side. so all changes are done in front
- store an index into a valid list which is sane and sorted by voice then page then value (store in PAR_P*_DEST)
- any time we receive a value from cortex, we translate it to this value
- any time we send the value to cortex we translate it to a param number
- frontParser_stepData doesn't need to change because it's only used for transferring data between file and sequencer and vice versa


___fixes in progress (QA test list)___
- Added midi note off when switching patterns
- Added midi note off when changing midi channel
- Added midi note off when muting voice
- Move midi note off into function (affects sequencer playing, should still send note off, and stop sequencer should send all off)
- front parset set p1 dest optimize (autom targets 1 and 2 should still default to off)

mtc stuff
- rearrange some code in midi parser for readability
- add code in front to recognize start/stop from back and toggle sequncer play stop (the led is meaningless as it flashes)
- play will start when mtc 0:0:0:0 received and stop when mtc stops
- prog change is recognized on MIDI port and causes pattern change
- prog change is sent to MIDI port when a pattern changes
- fix midiparser to properly recognize channel messages

routing stuff
- MidiStruct is modified to store more info for routing
- code rearranged so that parseMidiMessage handles all messages and does routing midi and usb
- add menu item for midi routing which can be in 1 of 6 states
- midi routing menu item will set routing options on back end
- back end will respond to midi routing options and save state
- back end will route midi messages to usb/midi as appropriate
- usb_sendMidi is changed to take a midi message so that it can check the number of bytes to send
- keep track of sysex mode, and use this for routing sysex data properly 
still needed:
still need work in usb reception of sysex data bytes (how many bytes will be set at a time?)
need to properly interpret note-on messages according to the setting of midi note for each voice
check the program change as it relates to channels

filtering stuff:
- added function to set filter byte
- added code in midi parsing to ignore messages if they are filtered
- added code in sequencer to not send out messages if they are filtered
- fixed avr side to add two new menu items for tx filter and rx filter
- avr side code to send filter settings
- back end code to receive filter settings and set bits
- prog change code will now send on the channel associated with voice 1

code cleanup prior to global menu expansion (GMENU):
- button handling code refactoring.
- check shift button release when in perf mode. should it do anything with mute led's on voices? (code might have a bug)

note TEXT_SKIP is only used as a spacer to force items onto page 2 if they belong there
things to try:
go to 1st page on page 1 of any voice, encode to left and encode left before 1st item. What happens
go to a page that has two full pages and scroll right, does it go to next page?
